<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Torrpeddo | Premium Torrent Client</title>
    <link rel="stylesheet" href="static/css/styles.css">
</head>

<body>
    <div class="container">
        <header>
            <h1>Torrpeddo</h1>
            <div id="connection-status" style="font-size: 0.75rem; color: var(--success);">‚óè Connected</div>
        </header>

        <section class="card">
            <div class="controls">
                <input type="text" id="magnet-input" placeholder="Paste magnet link here..."
                    onkeydown="if(event.key === 'Enter') addMagnet()">
                <button onclick="addMagnet()">Add Magnet</button>
                <label for="torrent-upload" class="button"
                    style="background: var(--border); padding: 0.75rem 1.5rem; border-radius: 0.5rem; cursor: pointer; display: inline-block;">Upload
                    .torrent</label>
                <input type="file" id="torrent-upload" style="display: none" onchange="uploadTorrent()">
            </div>
            <div id="toast" class="toast"></div>
            <div class="destination-bar">
                <span>Destination: <span id="current-dir"
                        style="color: var(--text-main);">/Downloads/Torrpeddo</span></span>
                <button onclick="changeDir()"
                    style="padding: 0.25rem 0.75rem; font-size: 0.75rem; background: transparent; border: 1px solid var(--border);">Change</button>
            </div>
        </section>

        <section class="torrent-list" id="torrent-container">
            <!-- Torrents will be injected here -->
        </section>
    </div>

    <script>
        /**
         * renderer/index.html - Frontend Logic
         * 
         * This script manages the user interface and communicates with the 
         * Python backend via the Electron context bridge (window.electronAPI).
         */

        // Map to keep track of pending IPC requests and their promise handlers
        const pendingRequests = new Map();

        /**
         * IPC Response Listener:
         * Listens for 'python-data' messages sent from the main process.
         */
        window.electronAPI.receive('python-data', (data) => {
            // If the message has a matching ID, resolve the corresponding promise
            if (data.id && pendingRequests.has(data.id)) {
                const { resolve, reject } = pendingRequests.get(data.id);
                pendingRequests.delete(data.id);
                if (data.error) reject(data.error);
                else resolve(data.data);
            }
        });

        /**
         * sendCommand: Helper function to send commands to Python via IPC.
         * Returns a Promise that resolves when Python returns a response.
         */
        function sendCommand(command, args = {}) {
            const id = Math.random().toString(36).substr(2, 9); // Generate a unique request ID
            return new Promise((resolve, reject) => {
                pendingRequests.set(id, { resolve, reject });
                window.electronAPI.send('to-python', { id, command, args });
            });
        }

        /**
         * fetchStatus: Polls the backend for live torrent metrics.
         */
        async function fetchStatus() {
            try {
                const torrents = await sendCommand('get_status');
                renderTorrents(torrents);
            } catch (err) {
                console.error('Failed to fetch status', err);
            }
        }

        /**
         * fetchConfig: Retrieves current configuration settings (e.g. download directory).
         */
        async function fetchConfig() {
            try {
                const data = await sendCommand('get_config');
                document.getElementById('current-dir').textContent = data.download_dir;
            } catch (err) {
                console.error('Failed to fetch config', err);
            }
        }

        /**
         * renderTorrents: Dynamically updates the UI list of active downloads.
         */
        function renderTorrents(torrents) {
            const container = document.getElementById('torrent-container');
            if (!torrents || torrents.length === 0) {
                container.innerHTML = '<div style="text-align: center; color: var(--text-muted); padding: 2rem;">No active downloads</div>';
                return;
            }

            container.innerHTML = torrents.map(t => `
                <div class="card torrent-item active">
                    <div class="torrent-header">
                        <div style="font-weight: 600;">${t.name || 'Fetching metadata...'}</div>
                        <div class="badge ${t.is_seeding ? 'badge-seeding' : 'badge-downloading'}">${t.state}</div>
                    </div>
                    <div class="progress-container">
                        <div class="progress-bar" style="width: ${t.progress}%"></div>
                    </div>
                    <div class="stats">
                        <div class="stat-item">‚Üì ${t.download_rate.toFixed(1)} kB/s</div>
                        <div class="stat-item">‚Üë ${t.upload_rate.toFixed(1)} kB/s</div>
                        <div class="stat-item">üë• ${t.num_peers} peers</div>
                        <div class="stat-item" style="margin-left: auto;">${t.progress.toFixed(1)}%</div>
                        ${t.is_paused
                    ? `<button onclick="resumeTorrent('${t.info_hash}')" style="background: transparent; padding: 0; color: var(--text-main); font-size: 0.75rem; margin-right: 1rem;">Resume</button>`
                    : `<button onclick="pauseTorrent('${t.info_hash}')" style="background: transparent; padding: 0; color: var(--text-muted); font-size: 0.75rem; margin-right: 1rem;">Pause</button>`
                }
                        ${t.is_seeding ? `<button onclick="openFolder('${t.info_hash}')" style="background: transparent; padding: 0; color: var(--success); font-size: 0.75rem; margin-right: 1rem;">Open Folder</button>` : ''}
                        ${t.is_seeding ? `<button onclick="removeTorrent('${t.info_hash}')" style="background: transparent; padding: 0; color: #ef4444; font-size: 0.75rem;">Remove</button>` : ''}
                    </div>
                </div>
            `).join('');
        }

        /**
         * addMagnet: Grabs the magnet URL from the input and sends it to the backend.
         */
        async function addMagnet() {
            const magnet = document.getElementById('magnet-input').value;
            if (!magnet) return;

            showToast('Adding magnet link...', 'info');

            try {
                const res = await sendCommand('add_magnet', { magnet_url: magnet });
                if (res.success) {
                    document.getElementById('magnet-input').value = '';
                    showToast('Magnet link added successfully', 'success');
                    fetchStatus();
                } else {
                    showToast(res.error || 'Failed to add magnet link', 'error');
                }
            } catch (err) {
                showToast('Bridge error: ' + err, 'error');
                console.error(err);
            }
        }

        /**
         * uploadTorrent: Handles .torrent file selection.
         * Since we are in Electron, we pass the absolute file path to Python.
         */
        async function uploadTorrent() {
            const fileInput = document.getElementById('torrent-upload');
            const file = fileInput.files[0];
            if (!file) return;

            showToast('Uploading torrent file...', 'info');
            try {
                // In Electron, file.path is the actual absolute path on disk
                const res = await sendCommand('add_torrent_file', { filepath: file.path });
                if (res.success) {
                    showToast('Torrent file added successfully', 'success');
                    fetchStatus();
                } else {
                    showToast(res.error || 'Failed to add torrent', 'error');
                }
            } catch (err) {
                console.error(err);
                showToast('Bridge error', 'error');
            }
        }

        /**
         * removeTorrent, pauseTorrent, resumeTorrent, openFolder:
         * Action handlers that send specific commands to the Python TorrentManager.
         */
        async function removeTorrent(hash) {
            if (confirm('Are you sure you want to remove this torrent?')) {
                await sendCommand('remove_torrent', { info_hash: hash });
                fetchStatus();
            }
        }

        async function changeDir() {
            showToast('Opening folder selector...', 'info');
            try {
                const selData = await sendCommand('select_dir');
                if (selData.cancelled) {
                    showToast('Selection cancelled', 'info');
                    return;
                }

                const newDir = selData.path;
                if (!newDir) return;

                const res = await sendCommand('set_config', { download_dir: newDir });
                if (res.success) {
                    showToast('Download directory updated', 'success');
                    fetchConfig();
                } else {
                    showToast('Invalid directory', 'error');
                }
            } catch (err) {
                console.error(err);
                showToast('Failed to open selector', 'error');
            }
        }

        async function pauseTorrent(hash) {
            await sendCommand('pause_torrent', { info_hash: hash });
            fetchStatus();
        }

        async function resumeTorrent(hash) {
            await sendCommand('resume_torrent', { info_hash: hash });
            fetchStatus();
        }

        async function openFolder(hash) {
            try {
                const res = await sendCommand('open_folder', { info_hash: hash });
                if (res.success) {
                    showToast('Opening folder...', 'success');
                } else {
                    showToast(res.message || 'Failed to open folder', 'error');
                }
            } catch (err) {
                console.error(err);
                showToast('Bridge error', 'error');
            }
        }

        /**
         * UI Helper: Shows a temporary toast notification.
         */
        function showToast(message, type = 'info') {
            const toast = document.getElementById('toast');
            toast.textContent = message;
            toast.className = `toast show ${type}`;
            setTimeout(() => {
                toast.className = 'toast';
            }, 3000);
        }

        // Initial setup and polling interval
        fetchConfig();
        setInterval(fetchStatus, 2000);
    </script>
    <style>
        .toast {
            visibility: hidden;
            min-width: 250px;
            margin-left: -125px;
            background-color: var(--bg-card);
            backdrop-filter: blur(12px);
            border: 1px solid var(--border);
            color: #fff;
            text-align: center;
            border-radius: 0.5rem;
            padding: 1rem;
            position: fixed;
            z-index: 1000;
            left: 50%;
            bottom: 30px;
            font-size: 0.875rem;
            transition: visibility 0s, opacity 0.5s linear;
            opacity: 0;
        }

        .toast.show {
            visibility: visible;
            opacity: 1;
        }

        .toast.success {
            border-color: var(--success);
        }

        .toast.error {
            border-color: #ef4444;
        }
    </style>
</body>

</html>